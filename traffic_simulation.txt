import sys
import random
import math
import threading

import queue
from PyQt6 import QtWidgets, uic

Form, Window = uic.loadUiType("traffic.ui")


class TrafficSimulation(QtWidgets.QWidget):

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.setup_handlers()
        self.model_state = "stopped"

    def setup_handlers(self):
        """Настройка обработчиков событий для всех элементов."""
        self.sn_bridge = self.main_window.findChild(QtWidgets.QPushButton, 'snBridge')
        self.ns_bridge = self.main_window.findChild(QtWidgets.QPushButton, 'nsBridge')
        self.the_barricade = self.main_window.findChild(QtWidgets.QPushButton, 'barricade')
        self.go_button = self.main_window.findChild(QtWidgets.QPushButton, 'goButton')
        self.reset_button = self.main_window.findChild(QtWidgets.QPushButton, 'resetButton')
        self.max_cars_input = self.main_window.findChild(QtWidgets.QLineEdit, 'maxCarsInput')
        self.launch_rate_slider = self.main_window.findChild(QtWidgets.QSlider, 'launchRateSlider')
        self.launch_rate_output = self.main_window.findChild(QtWidgets.QLabel, 'launchRateOutput')
        self.congestion_slider = self.main_window.findChild(QtWidgets.QSlider, 'congestionSlider')
        self.congestion_output = self.main_window.findChild(QtWidgets.QLabel, 'congestionOutput')
        self.launch_timing_menu = self.main_window.findChild(QtWidgets.QComboBox, 'launchTimingMenu')
        self.routing_mode_menu = self.main_window.findChild(QtWidgets.QComboBox, 'routingModeMenu')
        self.speed_menu = self.main_window.findChild(QtWidgets.QComboBox, 'speedMenu')
        self.selection_method_menu = self.main_window.findChild(QtWidgets.QComboBox, 'selectionMethodMenu')
        self.geek_toggle = self.main_window.findChild(QtWidgets.QCheckBox, 'geekToggle')
        self.hint_toggle = self.main_window.findChild(QtWidgets.QCheckBox, 'hintToggle')

        # # Подключение обработчиков событий
        # self.sn_bridge.clicked.connect(self.sn_bridge)
        # self.ns_bridge.clicked.connect(self.ns_bridge)
        # self.the_barricade.clicked.connect(self.barricade)
        # self.go_button.clicked.connect(self.go_stop_button)
        # self.reset_button.clicked.connect(self.on_reset_button_click)
        # self.launch_rate_slider.valueChanged.connect(self.update_launch_rate)
        # self.congestion_slider.valueChanged.connect(self.update_congestion)

    def initialize_simulation(self):
        # Инициализация переменных симуляции
        self.model_state = "stopped"
        self.bridge_blocked = True
        self.routing_mode = "selfish"
        self.speed_mode = "theoretical"
        self.selection_method = "minimum"
        self.launch_timing = "poisson"
        self.launch_timer = self.poisson
        self.global_clock = 0
        self.next_departure = 0
        self.max_cars = float('inf')
        self.car_radius = 3
        self.car_length = 2 * self.car_radius
        self.total_path_length = 1620
        self.car_queue_size = (self.total_path_length / self.car_length) + 10
        self.car_array = [None] * int(self.car_queue_size)
        self.speed_limit = 3
        self.launch_rate = 0.55
        self.congestion_coef = 0.55
        self.quickest_trip = 582 / self.speed_limit

        simulation = TrafficSimulation()
        # Создание узлов сети

        self.orig = Node("orig", simulation=simulation)
        self.dest = Node("dest", simulation=simulation)
        self.south = Node("south", simulation=simulation)
        self.north = Node("north", simulation=simulation)





class Link:
    def __init__(self, id_str, o_node, d_node, simulation):
        self.go_button = None
        self.id = id_str
        self.svg_path = None  # Этот атрибут будет связан с соответствующим элементом в интерфейсе
        self.path_length = 0  # Будет рассчитано на основе svg
        self.origin_xy = None  # Начальная точка пути
        self.destination_xy = None  # Конечная точка пути
        self.origin_node = o_node
        self.destination_node = d_node
        self.open_to_traffic = True
        self.car_queue = queue.Queue(simulation.car_queue_size)
        self.congestible = "thin-road" in self.svg_path.get_class_list()  # Проверка на тип дороги
        self.occupancy = self.car_queue.len
        self.speed = simulation.speed_limit
        self.travel_time = self.path_length / self.speed

    def update_speed(self):
        self.speed = simulation.speed_limit
        self.travel_time = self.path_length / self.speed

    def get_car_xy(self, progress):
        return self.svg_path.get_point_at_length(progress)

    def drive(self):
        if self.car_queue.len > 0:
            first_car = self.car_queue.peek(0)
            first_car.past_progress = first_car.progress
            first_car.progress = min(self.path_length, first_car.progress + self.speed)
            first_car.odometer += first_car.progress - first_car.past_progress
            car_xy = self.get_car_xy(first_car.progress)
            first_car.avatar.set_attribute("cx", car_xy.x)
            first_car.avatar.set_attribute("cy", car_xy.y)

            for i in range(1, self.car_queue.len):
                leader = self.car_queue.peek(i - 1)
                follower = self.car_queue.peek(i)
                follower.past_progress = follower.progress
                follower.progress = min(follower.progress + self.speed, leader.progress - simulation.car_length)
                follower.odometer += follower.progress - follower.past_progress
                car_xy = self.get_car_xy(follower.progress)
                follower.avatar.set_attribute("cx", car_xy.x)
                follower.avatar.set_attribute("cy", car_xy.y)

            if first_car.progress >= self.path_length and self.destination_node.has_room():
                self.destination_node.accept(self.car_queue.dequeue())
                self.update_speed()

    def evacuate(self):
        while self.car_queue.len > 0:
            car = self.car_queue.dequeue()
            car.avatar.set_attribute("display", "none")
            car.avatar.set_attribute("fill", "#000")
            car.avatar.set_attribute("cx", 0)
            car.avatar.set_attribute("cy", 0)
            car.route = []
            car.progress = 0
            car.odometer = 0
            parking_lot.enqueue(car)
        self.update_speed()

    def coin_flip(self):
        return random.random() < 0.5

    def poisson(self, lambda_: float) -> float:
        return -math.log(1 - random.random()) / lambda_

    def uniform(self, lambda_: float) -> float:
        return random.random() * 2 / lambda_

    def periodic(self, lambda_: float) -> float:
        return 1 / lambda_

    def start_simulation(self):
        self.model_state = "running"
        self.animation_timer.start(100)  # обновление каждую 1/10 секунды

    def stop_simulation(self):
        self.model_state = "stopping"
        self.animation_timer.stop()

    def reset_simulation(self):
        self.model_state = "stopped"
        self.global_clock = 0
        self.next_departure = 0
        self.car_array = [None] * int(self.car_queue_size)
        self.orig.reset()
        self.dest.reset()
        self.south.reset()
        self.north.reset()

    def update_simulation(self):
        if self.model_state == "running":
            self.global_clock += 1
            self.orig.dispatch()
            self.dest.dispatch()
            self.south.dispatch()
            self.north.dispatch()


class Node:
    def __init__(self, id_str, simulation):
        self.node_name = id_str
        self.x = 0  # Например, координаты на экране
        self.y = 0
        self.car = None

    def has_room(self):
        return self.car is None

    def accept(self, car):
        self.car = car

    def evacuate(self):
        if self.car:
            # Очистить визуальное представление машины
            self.car.avatar.setAttribute("display", "none")
            self.car.avatar.setAttribute("cx", 0)
            self.car.avatar.setAttribute("cy", 0)
            self.car.route = None
            self.car.progress = 0
            self.car.odometer = 0
            # parkingLot.enqueue(self.car) # Здесь парковка не реализована
            self.car = None

    def dispatch(self):
        if self.car:
            next_link = self.car.route.directions.get(self.node_name)  # найти следующий путь
            if next_link.car_q_len == 0 or next_link.car_q_last().progress >= simulation.car_length:
                self.car.progress = 0
                self.car.avatar.setAttribute("cx", self.x)
                self.car.avatar.setAttribute("cy", self.y)
                next_link.car_q_enqueue(self.car)
                next_link.update_speed()
                self.car = None

    def dispatch(self):
        if self.car:
            # Запись прибытия в панель статистики
            Dashboard.record_arrival(self.car)
            # Скрытие машины
            self.car.avatar.setAttribute("display", "none")
            self.car.avatar.setAttribute("cx", 0)
            self.car.avatar.setAttribute("cy", 0)
            self.car.avatar.setAttribute("fill", "#000")
            self.car.route = None
            self.car.progress = 0
            self.car.odometer = 0
            self.parking_lot.enqueue(self.car)  # Парковка для ожидания
            self.car = None


class RouteChooser:
    @staticmethod
    def random(route_list):
        return random.choice(route_list)

    @staticmethod
    def min(route_list):
        min_val = float('inf')
        min_routes = []
        for route in route_list:
            if route.travel_time < min_val:
                min_val = route.travel_time
                min_routes = [route]
            elif route.travel_time == min_val:
                min_routes.append(route)
        return random.choice(min_routes) if len(min_routes) > 1 else min_routes[0]

    @staticmethod
    def probabilistic(route_list):
        val_sum = sum(1 / route.travel_time for route in route_list)
        for route in route_list:
            route.travel_time /= val_sum
        r = random.random()
        accum = 0
        for route in route_list:
            accum += route.travel_time
            if r <= accum:
                return route

    @staticmethod
    def choose_route():
        available_routes = [Ab, aB] if bridge_blocked else [Ab, aB, AB, ab]

        if routing_mode == "random":
            return RouteChooser.random(available_routes)
        else:  # routing_mode == "selfish"
            for route in available_routes:
                route.calc_travel_time()

            if selection_method == "minimum":
                return RouteChooser.min(available_routes)
            else:  # selection_method == "probabilistic"
                return RouteChooser.probabilistic(available_routes)

    # Пример создания объектов Link


a_link = Link("a", "orig", "south", simulation=simulation)
A_link = Link("A", "orig", "north", simulation=simulation)
b_link = Link("b", "north", "dest", simulation=simulation)
B_link = Link("B", "south", "dest", simulation=simulation)
sn_link = Link("sn-bridge", "south", "north", simulation=simulation)
ns_link = Link("ns-bridge", "north", "south", simulation=simulation)

# Закрытие некоторых дорог для движения
sn_link.open_to_traffic = False
ns_link.open_to_traffic = False


class Route:
    def __init__(self):
        self.label = ""
        self.paint_color = None
        self.directions = {"orig": None, "south": None, "north": None, "dest": None}
        self.itinerary = []
        self.route_length = 0
        self.travel_time = 0
        self.current_travel_time = 0
        self.chooser_val = 0

    def calc_route_length(self):
        """Вычисление длины маршрута."""
        self.route_length = sum(link.path_length for link in self.itinerary)

    def calc_travel_time(self):
        """Вычисление времени проезда по маршруту."""
        if speed_mode == "theoretical":
            self.calc_travel_time_theoretical()
        elif speed_mode == "actual":
            self.calc_travel_time_actual()
        else:
            self.calc_travel_time_historical()

    def calc_travel_time_theoretical(self):
        """Теоретическое время проезда по маршруту."""
        self.travel_time = sum(link.travel_time for link in self.itinerary)

    def calc_travel_time_actual(self):
        """Фактическое время проезда по маршруту."""
        num_cars = 0
        total_time = 0

        for car in car_array:
            if car.route == self and car.odometer > 0:
                velocity = (car.odometer / (global_clock - car.depart_time)) * speed_limit
                time = self.route_length / velocity
                total_time += time
                num_cars += 1

        if num_cars == 0:
            self.travel_time = self.route_length / speed_limit
        else:
            self.travel_time = total_time / num_cars

    def calc_travel_time_historical(self):
        """Историческое время проезда по маршруту."""
        if Dashboard.counts[self.label] == 0:
            self.travel_time = self.route_length / speed_limit
        else:
            self.travel_time = Dashboard.times[self.label] / Dashboard.counts[self.label]


# Создание маршрутов с соответствующими характеристиками
ab = Route()
ab.label = "Ab"
ab.paint_color = "#cb0130"
ab.directions = {"orig": a_link, "south": None, "north": b_link, "dest": parking_lot}
ab.itinerary = [a_link, b_link]
ab.calc_route_length()

a_b = Route()
a_b.label = "aB"
a_b.paint_color = "#1010a5"
a_b.directions = {"orig": a_link, "south": b_link, "north": None, "dest": parking_lot}
a_b.itinerary = [a_link, b_link]
a_b.calc_route_length()

ab_route = Route()
ab_route.label = "AB"
ab_route.paint_color = "#ffc526"
ab_route.directions = {"orig": a_link, "south": b_link, "north": ns_link, "dest": parking_lot}
ab_route.itinerary = [a_link, ns_link, b_link]
ab_route.calc_route_length()

a_b_route = Route()
a_b_route.label = "ab"
a_b_route.paint_color = "#4b9b55"
a_b_route.directions = {"orig": a_link, "south": sn_link, "north": b_link, "dest": parking_lot}
a_b_route.itinerary = [a_link, sn_link, b_link]
a_b_route.calc_route_length()


class Dashboard:
    def __init__(self):
        self.departure_count = 0
        self.arrival_count = 0
        self.counts = {
            "Ab": 0, "aB": 0, "AB": 0, "ab": 0, "total": 0
        }
        self.times = {
            "Ab": 0, "aB": 0, "AB": 0, "ab": 0, "total": 0
        }
        # В PyQt6 нужно будет подключить соответствующие элементы интерфейса
        self.count_readouts = {
            "Ab": self.ui.Ab_count,
            "aB": self.ui.aB_count,
            "AB": self.ui.AB_count,
            "ab": self.ui.ab_count,
            "total": self.ui.total_count
        }
        self.time_readouts = {
            "Ab": self.ui.Ab_time,
            "aB": self.ui.aB_time,
            "AB": self.ui.AB_time,
            "ab": self.ui.ab_time,
            "total": self.ui.total_time
        }

    def colorize(self):
        # Пример изменения цвета строк на основе значений
        self.ui.Ab_row.setStyleSheet(f"background-color: {Ab.paint_color}")
        self.ui.aB_row.setStyleSheet(f"background-color: {aB.paint_color}")
        self.ui.AB_row.setStyleSheet(f"background-color: {AB.paint_color}")
        self.ui.ab_row.setStyleSheet(f"background-color: {ab.paint_color}")
        self.ui.total_row.setStyleSheet("background-color: #000")

    def record_departure(self):
        self.departure_count += 1

    def record_arrival(self, car):
        elapsed = (global_clock - car.depart_time) / speed_limit
        route_code = car.route.label
        self.counts[route_code] += 1
        self.counts["total"] += 1
        self.times[route_code] += elapsed
        self.times["total"] += elapsed
        self.update_readouts()

    def update_readouts(self):
        for ct, count_widget in self.count_readouts.items():
            count_widget.setText(str(self.counts[ct]))

        for tm, time_widget in self.time_readouts.items():
            if self.counts[tm] == 0:
                time_widget.setText("--")
            else:
                average_time = (self.times[tm] / self.counts[tm]) / quickest_trip
                time_widget.setText(f"{average_time:.3f}")

    def reset(self):
        self.departure_count = 0
        self.arrival_count = 0
        for ct in self.counts:
            self.counts[ct] = 0
        for tm in self.times:
            self.times[tm] = 0
        self.update_readouts()


    def go_stop_button(self):
        """Обработчик для кнопки Go/Stop."""
        global model_state
        if model_state == "stopped":
            model_state = "running"
            self.go_button.text = "Stop"
            animate()
        elif model_state == "running":
            model_state = "stopping"
            self.go_button.text = "Wait"
            self.go_button.disabled = True

    def reset_model(self):
        """Сброс модели."""
        links_and_nodes = [a_link, a_link, b_link, b_link, ns_link, sn_link, self.orig, self.dest, self.north,
                           self.south]
        global global_clock, next_departure
        if self.model_state == "running":
            self.model_state = "stopped"
            self.go_button.text = "Go"
            self.window.clear_interval(animation_timer)
        for link_or_node in links_and_nodes:
            link_or_node.evacuate()
        global_clock = 0
        next_departure = 0
        Dashboard.reset()

    def set_max_cars(self):
        """Установка лимита машин."""
        limit = int(self.max_cars_input.text)
        global max_cars
        if limit == 0:
            max_cars = float('inf')
        else:
            max_cars = limit

    def toggle_bridge(self):
        """Переключение состояния моста."""
        global bridge_blocked
        bridge_blocked = not bridge_blocked
        sn_link.open_to_traffic = not sn_link.open_to_traffic
        ns_link.open_to_traffic = not ns_link.open_to_traffic
        self.sn_bridge.class_list.toggle("closed")
        self.ns_bridge.class_list.toggle("closed")
        self.the_barricade.class_list.toggle("hidden")

    def get_launch_rate(self):
        """Получение скорости запуска."""
        global launch_rate, next_departure
        launch_rate = max(self.launch_rate_slider.value, 0.001)
        self.launch_rate_output.text = f"{launch_rate:.2f}"
        next_departure = global_clock + launch_timer(launch_rate / self.speed_limit)

    def get_congestion_coef(self):
        """Получение коэффициента конгестии."""
        global congestion_coef
        congestion_coef = float(self.congestion_slider.value)
        self.congestion_output.text = f"{congestion_coef:.2f}"

    def get_launch_timing(self):
        """Получение времени запуска."""
        timings = {"poisson": self.poisson, "uniform": self.uniform, "periodic": self.periodic}
        selected_timing = self.launch_timing_menu.value
        global launch_timing, launch_timer
        launch_timing = selected_timing
        launch_timer = timings[selected_timing]

    def get_routing_mode(self):
        """Установка режима маршрутизации."""
        global routing_mode
        selected_mode = self.routing_mode_menu.value
        routing_mode = selected_mode

    def get_speed_mode(self):
        """Установка режима скорости."""
        global speed_mode
        selected_mode = self.speed_menu.value
        speed_mode = selected_mode

    def get_selection_method(self):
        """Установка метода выбора."""
        global selection_method
        selected_mode = self.selection_method_menu.value
        selection_method = selected_mode

class Car:
    def __init__(self):
        self.serial_number = None
        self.progress = 0
        self.past_progress = 0
        self.depart_time = 0
        self.arrive_time = 0
        self.route = None
        self.odometer = 0
        self.avatar = None  # Placeholder for the visual representation
        self.create_avatar()
        parking_lot.enqueue(self)

    def create_avatar(self):
        """Создание визуального представления машины."""
        self.avatar = Circle(x=0, y=0, radius=car_radius, fill_color="#000", display="none")
        frame.append(self.avatar)


def make_cars(n):
    """Создание n машин."""
    for i in range(n):
        car = Car()
        car.serial_number = i
        car_array.append(car)


def init():
    """Инициализация симуляции."""
    make_cars(car_queue_size)
    global global_clock
    global_clock = 0
    sync_controls()
    a_link.update_speed()
    b_link.update_speed()
    a_link.update_speed()
    b_link.update_speed()
    ns_link.update_speed()
    sn_link.update_speed()
    Dashboard.colorize()


def sync_controls():
    """Синхронизация контроллеров интерфейса."""
    congestion_slider.value = congestion_coef
    launch_rate_slider.value = launch_rate
    routing_mode_menu.value = routing_mode
    launch_timing_menu.value = launch_timing
    max_cars_input.value = ""


def save_stats():
    """Сохранение статистики."""
    routes = ["Ab", "aB", "AB", "ab"]
    print(f"launchRate: {launch_rate}, congestionCoef: {congestion_coef}, bridgeBlocked: {bridge_blocked}")
    for route in routes:
        print(route, Dashboard.count_readouts[route].text, Dashboard.time_readouts[route].text)
    print("total", Dashboard.count_readouts["total"].text, Dashboard.time_readouts["total"].text)


def launch_car():
    """Запуск машины."""
    global next_departure, global_clock
    if orig.has_room() and global_clock >= next_departure and model_state == "running" and parking_lot.len > 0:
        next_car = parking_lot.dequeue()
        next_car.depart_time = global_clock
        next_car.route = choose_route()
        next_car.avatar.setAttribute("fill", next_car.route.paint_color)
        next_car.avatar.setAttribute("cx", orig.x)
        next_car.avatar.setAttribute("cy", orig.y)
        orig.accept(next_car)
        next_car.avatar.setAttribute("display", "block")
        dashboard.record_departure()
        next_departure = global_clock + launch_timer(launch_rate / speed_limit)


def step():
    """Шаг модели."""
    global global_clock, model_state, next_departure

    if coin_flip():
        dest.dispatch()
        b_link.drive()
        dest.dispatch()
        b_link.drive()
    else:
        dest.dispatch()
        b_link.drive()
        dest.dispatch()
        b_link.drive()

    if coin_flip():
        north.dispatch()
        a_link.drive()
        north.dispatch()
        sn_link.drive()
    else:
        north.dispatch()
        sn_link.drive()
        north.dispatch()
        a_link.drive()

    if coin_flip():
        south.dispatch()
        ns_link.drive()
        south.dispatch()
        a_link.drive()
    else:
        south.dispatch()
        a_link.drive()
        south.dispatch()
        ns_link.drive()

    orig.dispatch()
    orig.dispatch()
    launch_car()
    global_clock += speed_limit

    if model_state == "stopping" and parking_lot.len == car_queue_size:
        animation_timer.cancel()
        model_state = "stopped"
        go_button.innerHTML = "Go"
        go_button.remove_attribute("disabled")
        save_stats()

    if model_state == "running" and Dashboard.departure_count >= max_cars:
        model_state = "stopping"
        go_button.innerHTML = "Wait"
        go_button.set_attribute("disabled", True)


def animate():
    """Запуск анимации с интервалом 15 миллисекунд."""
    global animation_timer
    animation_timer = threading.Timer(0.015, step)  # 0.015 секунд = 15 миллисекунд
    animation_timer.start()


simulation = TrafficSimulation()
link = Link(id_str="link1", o_node="origin", d_node="destination", simulation=simulation)
